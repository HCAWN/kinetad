<script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>
<script>
// // An example 128-bit key (16 bytes * 8 bits/byte = 128 bits)
// var key = aesjs.utils.hex.toBytes('4f25907df7f9b682f5f4c12260d195eef9487b39a51f2978337966317d589e27');
// // Convert text to bytes
// var text = 'I met a traveler from an antique land\nWho said: "Two vast and trunkless legs of stone\nStand in the desert... Near them, on the sand,\nHalf sunk, a shattered visage lies, whose frown,\nAnd wrinkled lip, and sneer of cold command,\nTell that its sculptor well those passions read\nWhich yet survive, stamped on these lifeless things,\nThe hand that mocked them, and the heart that fed:\nAnd on the pedestal these words appear:\n"My name is Ozymandias, king of kings:\nLook on my works, ye Mighty, and despair!"\nNothing beside remains. Round the decay\nOf that colossal wreck, boundless and bare\nThe lone and level sands stretch far away."';
// var textBytes = aesjs.utils.utf8.toBytes(text);
// // The counter is optional, and if omitted will begin at 1
// var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));
// var encryptedBytes = aesCtr.encrypt(textBytes);
// // To print or store the binary data, you may convert it to hex
// var encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);
// console.log(encryptedHex);
// // "a338eda3874ed884b6199150d36f49988c90f5c47fe7792b0cf8c7f77eeffd87
// //  ea145b73e82aefcf2076f881c88879e4e25b1d7b24ba2788"

















// // When ready to decrypt the hex string, convert it back to bytes
// var encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);
// // The counter mode of operation maintains internal state, so to
// // decrypt a new instance must be instantiated.
// var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));
// var decryptedBytes = aesCtr.decrypt(encryptedBytes);
// // Convert our bytes back into text
// var decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);
// console.log(decryptedText);
// // "Text may be any length you wish, no padding is required."
</script>


<script>
var sha256 = function sha256(ascii) {
	function rightRotate(value, amount) {
		return (value>>>amount) | (value<<(32 - amount));
	};
	
	var mathPow = Math.pow;
	var maxWord = mathPow(2, 32);
	var lengthProperty = 'length'
	var i, j; // Used as a counter across the whole file
	var result = ''

	var words = [];
	var asciiBitLength = ascii[lengthProperty]*8;
	
	//* caching results is optional - remove/add slash from front of this line to toggle
	// Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes
	// (we actually calculate the first 64, but extra values are just ignored)
	var hash = sha256.h = sha256.h || [];
	// Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes
	var k = sha256.k = sha256.k || [];
	var primeCounter = k[lengthProperty];
	/*/
	var hash = [], k = [];
	var primeCounter = 0;
	//*/

	var isComposite = {};
	for (var candidate = 2; primeCounter < 64; candidate++) {
		if (!isComposite[candidate]) {
			for (i = 0; i < 313; i += candidate) {
				isComposite[i] = candidate;
			}
			hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;
			k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;
		}
	}
	
	ascii += '\x80' // Append Æ‡' bit (plus zero padding)
	while (ascii[lengthProperty]%64 - 56) ascii += '\x00' // More zero padding
	for (i = 0; i < ascii[lengthProperty]; i++) {
		j = ascii.charCodeAt(i);
		if (j>>8) return; // ASCII check: only accept characters in range 0-255
		words[i>>2] |= j << ((3 - i)%4)*8;
	}
	words[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);
	words[words[lengthProperty]] = (asciiBitLength)
	
	// process each chunk
	for (j = 0; j < words[lengthProperty];) {
		var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration
		var oldHash = hash;
		// This is now the undefinedworking hash", often labelled as variables a...g
		// (we have to truncate as well, otherwise extra entries at the end accumulate
		hash = hash.slice(0, 8);
		
		for (i = 0; i < 64; i++) {
			var i2 = i + j;
			// Expand the message into 64 words
			// Used below if 
			var w15 = w[i - 15], w2 = w[i - 2];

			// Iterate
			var a = hash[0], e = hash[4];
			var temp1 = hash[7]
				+ (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1
				+ ((e&hash[5])^((~e)&hash[6])) // ch
				+ k[i]
				// Expand the message schedule if needed
				+ (w[i] = (i < 16) ? w[i] : (
						w[i - 16]
						+ (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0
						+ w[i - 7]
						+ (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1
					)|0
				);
			// This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble
			var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0
				+ ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj
			
			hash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()
			hash[4] = (hash[4] + temp1)|0;
		}
		
		for (i = 0; i < 8; i++) {
			hash[i] = (hash[i] + oldHash[i])|0;
		}
	}
	
	for (i = 0; i < 8; i++) {
		for (j = 3; j + 1; j--) {
			var b = (hash[i]>>(j*8))&255;
			result += ((b < 16) ? 0 : '') + b.toString(16);
		}
	}
	// //return result;
	// // An example 128-bit key (16 bytes * 8 bits/byte = 128 bits)
	// var key = aesjs.utils.hex.toBytes(result);
	// // Convert text to bytes
	// var text = 'I forgot how lush and electrified it was with you. The shaggy fragrant zaps continually passing back and forth, my fingertip to your clavicle, or your wrist rubbing mine to share gardenia oil. We so purred like dragonflies we kept the mosquitoes away and the conversation was heavy, mother-lacerated !""/?.';
	// var textBytes = aesjs.utils.utf8.toBytes(text);
	// // The counter is optional, and if omitted will begin at 1
	// var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));
	// var encryptedBytes = aesCtr.encrypt(textBytes);
	// // To print or store the binary data, you may convert it to hex
	// var encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);
	// return encryptedHex;




	// When ready to decrypt the hex string, convert it back to bytes
	var encryptedBytes = aesjs.utils.hex.toBytes('df4dcdaa5a3f9fe2a371c8f98d7e0ca98af724cd099aa88cb75346cc66d3d9c115578b3d4a22e0fa2497f5f3844138142b75b65b0ffcd8d369535f0d6f57c64093a9842c4069b804aeb6983fb8a952a61c45889cbe6ab21c5394d5ee8c4ce48b4528b9518f5b354034534dd5c63cdee89bf062c1cee879af764654c25b1fa665bfb3e2ac1d31a232cee6096f0a65c5ae19eaec1411d67a3de9f6e81a017eaa0683a15b089067df6c772cdebbc79d5fcbf0775d9fc77cb1bd06174714432e6d045282a2053bd6703d063b947a380308a882c14d8d5c27943033ee95566d7b110c92fd768fa412c4393850725ee2a33febd3a8f63f157fd55014432cd10dcfece8207d5141f70e07e2c197295f445b2f5394dcf30bd7effd7e020e30fbab3c02fcf988a26eedc4930105e3eb6a1a0ec338f3851b7f96a23aff7acd1c808534841e10a9c7bc86997503d6c13437d4b507177e63268dd07cc53528e0e0ea035054847145482debaff73aa7c627c5f01934ea93c633d85988f474a8d42b03c8f8b12dc3a8f84db16b67d989f92f3872748d423c88dd0c36d867c1f93deeb6be7a7a76b66e40c562dc604d09c7ceb639fb9dfea4cfd364d04484ee693172b16afce96b3f3b183219424eeac234562cad70b17f073fd60f7a2deb490f7a2f54bdb1ec9d2c4bed921105579ab5c12835c1b370485e9e6ec51a6da7a8b93dc4cda8c078eab7ddbedf7ebd20789f50c4e4fe532edcf248a84bca74228691a9260ba986e72230fcc39b9108bf8e61739b847ddfb9fbf33150f27c8b0ce9a84f7ced1c58fbce2fb232e66d5b2c361f45841ba3a5ed5716374d73670f18de5bc6bd3010f80ec3746c347c16ea51b3046c2eb74945020bc3965b');
	// The counter mode of operation maintains internal state, so to
	// decrypt a new instance must be instantiated.
	var aesCtr = new aesjs.ModeOfOperation.ctr(aesjs.utils.hex.toBytes(result), new aesjs.Counter(5));
	var decryptedBytes = aesCtr.decrypt(encryptedBytes);
	// Convert our bytes back into text
	var decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);
	console.log(decryptedText);
	// "Text may be any length you wish, no padding is required."
	return decryptedText

};
</script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<textarea id="input" placeholder="Password" rows=5></textarea>
<input id="button" type="button" value="calculate" />
<textarea id="output" rows=30 cols=60 style="text-align: center"></textarea>

<script>

$("#input").keyup(function(){
  document.getElementById('output').value = sha256(document.getElementById('input').value);
});

	document.getElementById('button').onclick = function () {
		document.getElementById('output').value = sha256(document.getElementById('input').value);
	};
</script>

